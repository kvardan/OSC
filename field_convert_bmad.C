// The code is written to fit magnetic field grid data (input file) with Cartesian Map (BMAD) functions
//
// The code will continue fitting again and again and improve the fit parameters until the user stops the code by CTRL+C,
// higher number for the fit tries is needed to avoid local minimums.
// Each fit starts with a set of initial (random) parameters in the range that is defined in field_fit_minuit.h
//
// Each time when the code finds a better set of fit parameters, it will save them into "best_fit_parameters.txt"
// While during the current status of the fit you can see in fit_parameters.txt
// There are also control plots are generated by draw_control_plots(ix, iy) function, where "ix" and "iy" integer arguments 
// are the number of grids 
//
// The user must provide a realistic errors for the field values (field_error_x, field_error_y, field_error_z):
// too small errors will increase the chi^2 which will not allow Minuit to find reasonable parameters,
// too large errors will decrease the chi^2 which will stop the minuit to continue improving the parameters after some level (tolerance)
//
// 3D array "use_family_form[n_terms][4][3]" defines the families and forms, as well as terms to be used during the fit.
// It is possible to configure this macro in a such way that for the first order it uses one of families, and for the next terms - other families
// see the first lines of fit_minuit()
//
// Please use an optimal configuration for "use_family_form[n_terms][4][3]"
// The more parameters are required to be fitted the slower fit procedure
// The larger input field data (grid points), the slower fit procedure
//
// In the current version the kz is not fitted. The helical undulator field we want to fit has fixed kz=2*pi/0.325
// kz_terms[] defines the kz values for each of terms. kz_terms[i] may have any value, they work independently during the fit
//
// The field grid divisions must be given in "fit_minuit.h" nx, ny, nz, also define starting points x0, y0, z0
//
// The ranges of fit parameters are defined by A_max=, x0_max, y0_max, phi_max=pi

#include "field_convert_bmad.h"

void field_convert_bmad()
{
  //define kz array for each term
  kz_terms[0]=kz;
  for (int i=1; i<n_terms;i++) kz_terms[i]=kz_terms[0]*double(i+1);

  //A canvas for control plots
  cc = new TCanvas("cont_plots", "cont_plots", 0, 0, 1600, 800);
  cc->Divide(3,1);

  // initialization
  for (int i_term=0; i_term<n_terms; i_term++)
  for (int i_family=0; i_family<4; i_family++)
  for (int i_form=0; i_form<3; i_form++)
  {
    use_family_form[i_term][i_family][i_form]=false;
  }

  //switching on all the terms for x and y family, form hyper-xy
  for (int i_term=0; i_term<n_terms; i_term++)
  {
//    use_family_form[i_term][0][1]=true;  //all the terms, 1-st family (x), 2-nd form (hyper-xy)
//    use_family_form[i_term][1][1]=true;  //all the terms, 2-nd family (y), 2-nd form (hyper-xy)
    use_family_form[i_term][3][0]=true;  //all the terms, 4-th family (sq), 1-st form (hyper-y)
    use_family_form[i_term][3][1]=true;  //all the terms, 4-th family (sq), 2-nd form (hyper-xy)
    use_family_form[i_term][3][2]=true;  //all the terms, 4-th family (sq), 3-rd form (hyper-x)
  }

//  read_field_data("field_extended.dat"); //read field data
  read_field_data("../v9_4_many_xare/hundulator_66731_450_xyz.table"); //read field data
  convert_bmad("bmad_field.table");
  draw_control_plots(3, 3);
//  fit_parameters();  //call minuit and fit the field with configured cartesian map functions
//  fit_GSLNLSMinimizer();
//  fit_with_minimizer();
//  fit_with_Levemberg_minimizer();
//  return 0;
}

void read_field_data(string fname)
{
  string line;
  ifstream file_table(fname.c_str());
  if ( file_table.is_open() )
  {
    while ( ! file_table.eof() )
    {
      getline(file_table,line);
      if(line.size()>50)  //avoid short lines that OPERA writes at the beginning
      {
        double x_tmp, y_tmp, z_tmp, bx_tmp, by_tmp, bz_tmp;
        istringstream vars(line);
        vars >> x_tmp >> y_tmp >> z_tmp >> bx_tmp >> by_tmp >> bz_tmp;
        int i_x = int((x_tmp-x0_start)/x0_step_size+0.1);
        int i_y = int((y_tmp-y0_start)/y0_step_size+0.1);
        int i_z = int((z_tmp-z0_start)/z0_step_size+0.1);
        x_bmad[i_x][i_y][i_z]  = x_tmp;
        y_bmad[i_x][i_y][i_z]  = y_tmp;
        z_bmad[i_x][i_y][i_z]  = z_tmp;
//        cout<<i_z<<"    "<<z_tmp<<endl;

        bx_bmad[i_x][i_y][i_z] = bx_tmp*scale_f;
        by_bmad[i_x][i_y][i_z] = by_tmp*scale_f;
        bz_bmad[i_x][i_y][i_z] = bz_tmp*scale_f;
      }
    }
  }
  file_table.close();
}

void convert_bmad(string fname)
{
  ofstream file_bmad_table(fname.c_str());
/*
0.01           ! position_scale
1              ! field_scale
-1, 0          ! Nx_min, Nx_max
0, 1           ! Ny_min, Ny_max
-1, 1          ! Nz_min, Ny_max
1.0, 2.0, 10.0 ! Distance between points: del_x, del_y, del_z
0.0, 0.0, 0.0  ! Grid origin offset x_off, y_off, z_off.
*/
  file_bmad_table<<"0.01           ! position_scale"<<endl;
  file_bmad_table<<"1              ! field_scale"<<endl;
  file_bmad_table<<left<<setw(12)<<(Form("%d, %d", int(x_bmad[0][0][0]/x0_step_size+0.1*x_bmad[0][0][0]/fabs(x_bmad[0][0][0])), int(x_bmad[nx-1][0][0]/x0_step_size+0.1*x_bmad[nx-1][0][0]/fabs(x_bmad[nx-1][0][0]))))<<"   ! Nx_min, Nx_max"<<endl;
  file_bmad_table<<left<<setw(12)<<(Form("%d, %d", int(y_bmad[0][0][0]/y0_step_size+0.1*y_bmad[0][0][0]/fabs(y_bmad[0][0][0])), int(y_bmad[0][ny-1][0]/y0_step_size+0.1*y_bmad[0][ny-1][0]/fabs(y_bmad[0][ny-1][0]))))<<"   ! Ny_min, Ny_max"<<endl;
  file_bmad_table<<left<<setw(12)<<(Form("%d, %d", int(z_bmad[0][0][0]/z0_step_size+0.1*z_bmad[0][0][0]/fabs(z_bmad[0][0][0])), int(z_bmad[0][0][nz-1]/z0_step_size+0.1*z_bmad[0][0][nz-1]/fabs(z_bmad[0][0][nz-1]))))<<"   ! Nz_min, Nz_max"<<endl;
  file_bmad_table<<x0_step_size<<", "<<y0_step_size<<", "<<z0_step_size<<"   ! Distance between points: del_x, del_y, del_z"<<endl;
  file_bmad_table<<"0.0, 0.0, 0.0  ! Grid origin offset x_off, y_off, z_off"<<endl;

  for (int i_x=0; i_x<nx; i_x++)
  for (int i_y=0; i_y<ny; i_y++)
  for (int i_z=0; i_z<nz; i_z+=1)
  {
    file_bmad_table<<setw(14)<<x_bmad[i_x][i_y][i_z]<<setw(14)<<y_bmad[i_x][i_y][i_z]<<setw(14)<<z_bmad[i_x][i_y][i_z]
                   <<setw(14)<<bx_bmad[i_x][i_y][i_z]<<setw(14)<<by_bmad[i_x][i_y][i_z]<<setw(14)<<bz_bmad[i_x][i_y][i_z]<<endl;
  }
  file_bmad_table.close();

}
void fit_GSLNLSMinimizer()
{
    string name_family[4]={"x", "y", "qu", "sq"};
    string name_form[3]={"hyper-y", "hyper-xy", "hyper-x"};

    for (int k=0; k<n_terms; k++)  //terms
    for (int i=0; i<4; i++)  //families
    for (int j=0; j<3; j++)  //forms
    {
      if (use_family_form[k][i][j])
      {
        n_pars[k][i][j]=n_total;
        n_total+=5;
      }
    }

    cout<<"Fit parameters numbering"<<endl;
    cout<<"term    hyper-y     hyper-xy    hyper-x"<<endl;
    for (int k=0; k<n_terms; k++)
    for (int i=0; i<4; i++)
    {
      cout<<k<<"       ";
      for (int j=0; j<3; j++)
      {
        if(use_family_form[k][i][j])
        {
          cout<<n_pars[k][i][j]<<"-"<<n_pars[k][i][j]+5<<"         ";
        }
        else
        {
//          cout<<n_pars[k][i][j]<<"           ";
          cout<<"-           ";
        }
      }
      cout<<"     family "<<name_family[i]<<endl;
    }
    cout<<"Total "<<n_total<<" parameters will be optimized"<<endl;
    const int n_total_tmp=n_total;


    clog<<"fitting data with LM method..."<<endl;
    TRandom3 * rnd_2 = new TRandom3(0);

    Double_t vstart[n_max_pars];
    Double_t step[n_max_pars];

    while (itry>-1)
    {
      n_fit=0;
      itry++;
    for (int i_term=0; i_term<n_terms; i_term++)
    for (int i_family=0; i_family<4; i_family++)
    for (int i_form=0; i_form<3; i_form++)
    if (use_family_form[i_term][i_family][i_form])
    {
        vstart[n_pars[i_term][i_family][i_form]+0] = A_max*rnd_2->Rndm(); //from 0 to A_max
        vstart[n_pars[i_term][i_family][i_form]+1] = kz_terms[i_term]*rnd_2->Rndm(); //from 0 to kz_terms[i]
        vstart[n_pars[i_term][i_family][i_form]+2] = x0_max*(1.-2.*rnd_2->Rndm()); //from -x0 to x0
        vstart[n_pars[i_term][i_family][i_form]+3] = y0_max*(1.-2.*rnd_2->Rndm()); //from -y0 to y0
        vstart[n_pars[i_term][i_family][i_form]+4] = phi_max*(1.-2.*rnd_2->Rndm()); // from -pi to pi
    }

    ROOT::Math::Functor f(&fcn_family_form_minimizer,n_total_tmp);
    ROOT::Fit::Fitter fitter;
    fitter.SetFCN(f, vstart);
    bool okk = fitter.FitFCN();
    cout<<"fit status "<<okk<<endl;
    }
}


void fit_with_minimizer()
{
    string name_family[4]={"x", "y", "qu", "sq"};
    string name_form[3]={"hyper-y", "hyper-xy", "hyper-x"};

    for (int k=0; k<n_terms; k++)  //terms
    for (int i=0; i<4; i++)  //families
    for (int j=0; j<3; j++)  //forms
    {
      if (use_family_form[k][i][j])
      {
        n_pars[k][i][j]=n_total;
        n_total+=5;
      }
    }

    cout<<"Fit parameters numbering"<<endl;
    cout<<"term    hyper-y     hyper-xy    hyper-x"<<endl;
    for (int k=0; k<n_terms; k++)
    for (int i=0; i<4; i++)
    {
      cout<<k<<"       ";
      for (int j=0; j<3; j++)
      {
        if(use_family_form[k][i][j])
        {
          cout<<n_pars[k][i][j]<<"-"<<n_pars[k][i][j]+5<<"         ";
        }
        else
        {
//          cout<<n_pars[k][i][j]<<"           ";
          cout<<"-           ";
        }
      }
      cout<<"     family "<<name_family[i]<<endl;
    }
    cout<<"Total "<<n_total<<" parameters will be optimized"<<endl;
    const int n_total_tmp=n_total;


    clog<<"fitting data..."<<endl;

    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Migrad");
    ROOT::Math::Functor f(&fcn_family_form_minimizer,n_total_tmp);
    TRandom3 * rnd_2 = new TRandom3(0);
    min->SetMaxFunctionCalls(1000000);
    min->SetMaxIterations(100000);
    min->SetTolerance(0.001);

    min->SetFunction(f);


    Double_t arglist[10];
    Int_t ierflg = 0;
    arglist[0] = 1;

//  Set starting values and step sizes for parameters
    Double_t vstart[n_max_pars];
    Double_t step[n_max_pars];

    double fit_pars[n_max_pars];
    for (int i=0; i<n_max_pars; i++)
    {
      step[i]=0.00001;
      fit_pars[i]=0.;
    }
    double chi2_min_best=1.e+30;
    cout<<"test000"<<endl;
    cout<<"test001"<<endl;

    while (itry>-1)
    {
      n_fit=0;
      itry++;
      for (int i_term=0; i_term<n_terms; i_term++)
      for (int i_family=0; i_family<4; i_family++)
      for (int i_form=0; i_form<3; i_form++)
      if (use_family_form[i_term][i_family][i_form])
      {
        vstart[n_pars[i_term][i_family][i_form]+0] = A_max*rnd_2->Rndm(); //from 0 to A_max
        vstart[n_pars[i_term][i_family][i_form]+1] = kz_terms[i_term]*rnd_2->Rndm(); //from 0 to kz_terms[i]
        vstart[n_pars[i_term][i_family][i_form]+2] = x0_max*(1.-2.*rnd_2->Rndm()); //from -x0 to x0
        vstart[n_pars[i_term][i_family][i_form]+3] = y0_max*(1.-2.*rnd_2->Rndm()); //from -y0 to y0
        vstart[n_pars[i_term][i_family][i_form]+4] = phi_max*(1.-2.*rnd_2->Rndm()); // from -pi to pi
        min->SetVariable(n_pars[i_term][i_family][i_form]+0, Form("par_%d%d%d_A1_",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+0],  step[n_pars[i_term][i_family][i_form]+0]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1],  step[n_pars[i_term][i_family][i_form]+1]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+2, Form("par_%d%d%d_x01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+2],  step[n_pars[i_term][i_family][i_form]+2]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+3, Form("par_%d%d%d_y01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+3],  step[n_pars[i_term][i_family][i_form]+3]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+4, Form("par_%d%d%d_phi1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+4], step[n_pars[i_term][i_family][i_form]+4]);
        if (i_form==2)
          min->SetVariable(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1], step[n_pars[i_term][i_family][i_form]+1]);

        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+0,  0.,         A_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+1,  0.,         kz_terms[i_term]);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+2, -1.*x0_max,  x0_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+3, -1.*y0_max,  y0_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+4, -1.*phi_max, phi_max);
        if (i_form==2)
          min->SetVariableLimits(n_pars[i_term][i_family][i_form]+1, kz_terms[i_term], 2*kz_terms[i_term]);

        par_names[n_pars[i_term][i_family][i_form]+0]=Form("A_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+1]=Form("kx_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+2]=Form("x0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+3]=Form("y0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+4]=Form("phi_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
      }

      min->Minimize();
      const double *pars_min = min->X();
      chi2_fit=fcn_family_form_minimizer(pars_min);

      if (chi2_min_best>chi2_fit)
      {
        chi2_min_best = chi2_fit;
        clog<<"try:"<<itry<<" better fit parameters are found   with chi2="<<chi2_fit<<"    saved in fit_parameters.txt (or best_fit_parameters.txt)."<<endl;
        clog<<"\033[1;34m If you are not satisfied with the current results, let the code continue working (to avoid local minimums) \033[0m "<<endl;
        ofstream fout("best_fit_parameters.txt");
        fout<<"chi2="<<chi2_fit<<endl;

        for (int i=0; i<n_total; i++)
        {
          fit_par_res[i]=pars_min[i];
        }
        for (int i=0; i<n_total; i++)
        {
          if (i%5==0) fout<<endl;
          fout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<fit_par_res[i]<<setw(20)<<"    error: "<<fit_par_res_Err[i]<<endl;
          fit_par_tmp[i]=fit_par_res[i];
        }
        fout.close();
        draw_control_plots(0, 0);
        int a=system("mv field_profile.gif best_field_profile.gif");
        cout<<endl;
      }

    }
}


void fit_with_Levemberg_minimizer()
{
    string name_family[4]={"x", "y", "qu", "sq"};
    string name_form[3]={"hyper-y", "hyper-xy", "hyper-x"};

    for (int k=0; k<n_terms; k++)  //terms
    for (int i=0; i<4; i++)  //families
    for (int j=0; j<3; j++)  //forms
    {
      if (use_family_form[k][i][j])
      {
        n_pars[k][i][j]=n_total;
        n_total+=5;
      }
    }

    cout<<"Fit parameters numbering"<<endl;
    cout<<"term    hyper-y     hyper-xy    hyper-x"<<endl;
    for (int k=0; k<n_terms; k++)
    for (int i=0; i<4; i++)
    {
      cout<<k<<"       ";
      for (int j=0; j<3; j++)
      {
        if(use_family_form[k][i][j])
        {
          cout<<n_pars[k][i][j]<<"-"<<n_pars[k][i][j]+5<<"         ";
        }
        else
        {
//          cout<<n_pars[k][i][j]<<"           ";
          cout<<"-           ";
        }
      }
      cout<<"     family "<<name_family[i]<<endl;
    }
    cout<<"Total "<<n_total<<" parameters will be optimized"<<endl;
    const int n_total_tmp=n_total;


    clog<<"fitting data..."<<endl;

//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Migrad");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Migrad");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Simplex");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Combined");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Scan");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Fumili");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiMin", "ConjugateFR");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiMin", "ConjugatePR");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiMin", "BFGS");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiMin", "BFGS2");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiMin", "SteepestDescent");
    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLMultiFit", "");
//    ROOT::Math::Minimizer* min = ROOT::Math::Factory::CreateMinimizer("GSLSimAn", "");

//    ROOT::Math::GSLNLSMinimizer min;
//    ROOT::Math::GSLSimAnMinimizer min;
//    ROOT::Math::GSLMinimizer min( ROOT::Math::kVectorBFGS );
      // kConjugateFR, kConjugatePR, kVectorBFGS,
      // kVectorBFGS2, kSteepestDescent

    ROOT::Math::Functor f(&fcn_family_form_minimizer,n_total_tmp);
    TRandom3 * rnd_2 = new TRandom3(0);
    min->SetMaxFunctionCalls(1000000);
    min->SetMaxIterations(100000);
    min->SetTolerance(0.001);

    min->SetFunction(f);


    Double_t arglist[10];
    Int_t ierflg = 0;
    arglist[0] = 1;

//  Set starting values and step sizes for parameters
    Double_t vstart[n_max_pars];
    Double_t step[n_max_pars];

    double fit_pars[n_max_pars];
    for (int i=0; i<n_max_pars; i++)
    {
      step[i]=0.00001;
      fit_pars[i]=0.;
    }
    double chi2_min_best=1.e+30;
    cout<<"test000"<<endl;
    cout<<"test001"<<endl;

//    while (itry>-1)
    {
      n_fit=0;
      itry++;
      for (int i_term=0; i_term<n_terms; i_term++)
      for (int i_family=0; i_family<4; i_family++)
      for (int i_form=0; i_form<3; i_form++)
      if (use_family_form[i_term][i_family][i_form])
      {
        vstart[n_pars[i_term][i_family][i_form]+0] = A_max*rnd_2->Rndm(); //from 0 to A_max
        vstart[n_pars[i_term][i_family][i_form]+1] = kz_terms[i_term]*rnd_2->Rndm(); //from 0 to kz_terms[i]
        vstart[n_pars[i_term][i_family][i_form]+2] = x0_max*(1.-2.*rnd_2->Rndm()); //from -x0 to x0
        vstart[n_pars[i_term][i_family][i_form]+3] = y0_max*(1.-2.*rnd_2->Rndm()); //from -y0 to y0
        vstart[n_pars[i_term][i_family][i_form]+4] = phi_max*(1.-2.*rnd_2->Rndm()); // from -pi to pi
        min->SetVariable(n_pars[i_term][i_family][i_form]+0, Form("par_%d%d%d_A1_",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+0],  step[n_pars[i_term][i_family][i_form]+0]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1],  step[n_pars[i_term][i_family][i_form]+1]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+2, Form("par_%d%d%d_x01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+2],  step[n_pars[i_term][i_family][i_form]+2]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+3, Form("par_%d%d%d_y01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+3],  step[n_pars[i_term][i_family][i_form]+3]);
        min->SetVariable(n_pars[i_term][i_family][i_form]+4, Form("par_%d%d%d_phi1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+4], step[n_pars[i_term][i_family][i_form]+4]);
        if (i_form==2)
          min->SetVariable(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1], step[n_pars[i_term][i_family][i_form]+1]);

        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+0,  0.,         A_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+1,  0.,         kz_terms[i_term]);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+2, -1.*x0_max,  x0_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+3, -1.*y0_max,  y0_max);
        min->SetVariableLimits(n_pars[i_term][i_family][i_form]+4, -1.*phi_max, phi_max);
        if (i_form==2)
          min->SetVariableLimits(n_pars[i_term][i_family][i_form]+1, kz_terms[i_term], 2*kz_terms[i_term]);

        par_names[n_pars[i_term][i_family][i_form]+0]=Form("A_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+1]=Form("kx_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+2]=Form("x0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+3]=Form("y0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+4]=Form("phi_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
      }

      min->Minimize();
      const double *pars_min = min->X();
      chi2_fit=fcn_family_form_minimizer(pars_min);

      if (chi2_min_best>chi2_fit)
      {
        chi2_min_best = chi2_fit;
        clog<<"try:"<<itry<<" better fit parameters are found   with chi2="<<chi2_fit<<"    saved in fit_parameters.txt (or best_fit_parameters.txt)."<<endl;
        clog<<"\033[1;34m If you are not satisfied with the current results, let the code continue working (to avoid local minimums) \033[0m "<<endl;
        ofstream fout("best_fit_parameters.txt");
        fout<<"chi2="<<chi2_fit<<endl;

        for (int i=0; i<n_total; i++)
        {
          fit_par_res[i]=pars_min[i];
        }
        for (int i=0; i<n_total; i++)
        {
          if (i%5==0) fout<<endl;
          fout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<fit_par_res[i]<<setw(20)<<"    error: "<<fit_par_res_Err[i]<<endl;
          fit_par_tmp[i]=fit_par_res[i];
        }
        fout.close();
        draw_control_plots(0, 0);
        int a=system("mv field_profile.gif best_field_profile.gif");
        cout<<endl;
      }

    }
}




void fit_parameters()
{
    string name_family[4]={"x", "y", "qu", "sq"};
    string name_form[3]={"hyper-y", "hyper-xy", "hyper-x"};

    for (int k=0; k<n_terms; k++)  //terms
    for (int i=0; i<4; i++)  //families
    for (int j=0; j<3; j++)  //forms
    {
      if (use_family_form[k][i][j])
      {
        n_pars[k][i][j]=n_total;
        n_total+=5;
      }
    }

    cout<<"Fit parameters numbering"<<endl;
    cout<<"term    hyper-y     hyper-xy    hyper-x"<<endl;
    for (int k=0; k<n_terms; k++)
    for (int i=0; i<4; i++)
    {
      cout<<k<<"       ";
      for (int j=0; j<3; j++)
      {
        if(use_family_form[k][i][j])
        {
          cout<<n_pars[k][i][j]<<"-"<<n_pars[k][i][j]+5<<"         ";
        }
        else
        {
//          cout<<n_pars[k][i][j]<<"           ";
          cout<<"-           ";
        }
      }
      cout<<"     family "<<name_family[i]<<endl;
    }
    cout<<"Total "<<n_total<<" parameters will be optimized"<<endl;
    const int n_total_tmp=n_total;


    clog<<"fitting data..."<<endl;

//    min->SetMaxFunctionCalls(1000000);
//    min->SetMaxIterations(100000);
//    min->SetTolerance(0.001);
//    ROOT::Math::Functor f(&RosenBrock,2);

    TMinuit *gMinuit_fit_pars = new TMinuit(n_total);  //initialize TMinuit with a maximum of 60
    gMinuit_fit_pars->SetPrintLevel(-1);
    TRandom3 * rnd_2 = new TRandom3(0);
    gMinuit_fit_pars->SetFCN(fcn_family_form);

    Double_t arglist[10];
    Int_t ierflg = 0;

    arglist[0] = 1;
    gMinuit_fit_pars->mnexcm("SET ERR", arglist ,1, ierflg);

//  Set starting values and step sizes for parameters
    Double_t vstart[n_max_pars];
    Double_t step[n_max_pars];

    double fit_pars[n_max_pars];
    for (int i=0; i<n_max_pars; i++)
    {
      step[i]=0.00001;
      fit_pars[i]=0.;
    }
    double chi2_min_best=1.e+30;

    if(1)
    {
      for (int i_term=0; i_term<n_terms; i_term++)
      for (int i_family=0; i_family<4; i_family++)
      for (int i_form=0; i_form<3; i_form++)
      if (use_family_form[i_term][i_family][i_form])
      {
        fit_pars[n_pars[i_term][i_family][i_form]+0] = 0.0;
        fit_pars[n_pars[i_term][i_family][i_form]+1] = kz_terms[i_term];
        fit_pars[n_pars[i_term][i_family][i_form]+2] = 0;
        fit_pars[n_pars[i_term][i_family][i_form]+3] = 0;
        fit_pars[n_pars[i_term][i_family][i_form]+4] = 0.;
      }
      int npar_tmp=0;
      Int_t & npar_tmp1=npar_tmp;
      double f_tmp=0;
      Double_t &f_tmp1=f_tmp;
      fcn_family_form(npar_tmp1, 0, f_tmp1,fit_pars, 0);
      cout<<"chi2 relative to 0 is "<<chi2_fit<<";"<<endl;
    }


    while (itry>-1)
    {
      n_fit=0;
      itry++;
      for (int i_term=0; i_term<n_terms; i_term++)
      for (int i_family=0; i_family<4; i_family++)
      for (int i_form=0; i_form<3; i_form++)
      if (use_family_form[i_term][i_family][i_form])
      {
        vstart[n_pars[i_term][i_family][i_form]+0] = A_max*rnd_2->Rndm(); //from 0 to A_max
        vstart[n_pars[i_term][i_family][i_form]+1] = kz_terms[i_term]*rnd_2->Rndm(); //from 0 to kz_terms[i]
        vstart[n_pars[i_term][i_family][i_form]+2] = x0_max*(1.-2.*rnd_2->Rndm()); //from -x0 to x0
        vstart[n_pars[i_term][i_family][i_form]+3] = y0_max*(1.-2.*rnd_2->Rndm()); //from -y0 to y0
        vstart[n_pars[i_term][i_family][i_form]+4] = phi_max*(1.-2.*rnd_2->Rndm()); // from -pi to pi
//        gMinuit_fit_pars->FixParameter(n_pars[i_term][i_family][i_form]+2);   //fix this parameter
//        gMinuit_fit_pars->FixParameter(n_pars[i_term][i_family][i_form]+3);   //fix this parameter
        gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+0, Form("par_%d%d%d_A1_",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+0],  step[n_pars[i_term][i_family][i_form]+0],  0.,         A_max,  ierflg);
        gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1],  step[n_pars[i_term][i_family][i_form]+1],  0.,         kz_terms[i_term], ierflg);
        gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+2, Form("par_%d%d%d_x01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+2],  step[n_pars[i_term][i_family][i_form]+2], -1.*x0_max,  x0_max, ierflg);
        gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+3, Form("par_%d%d%d_y01",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+3],  step[n_pars[i_term][i_family][i_form]+3], -1.*y0_max,  y0_max, ierflg);
        gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+4, Form("par_%d%d%d_phi1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+4], step[n_pars[i_term][i_family][i_form]+4], -1.*phi_max, phi_max, ierflg);
        if (i_form==2)
          gMinuit_fit_pars->mnparm(n_pars[i_term][i_family][i_form]+1, Form("par_%d%d%d_kx1",i_family+1, i_form+1, i_term+1), vstart[n_pars[i_term][i_family][i_form]+1], step[n_pars[i_term][i_family][i_form]+1], kz_terms[i_term], 2*kz_terms[i_term], ierflg);

        par_names[n_pars[i_term][i_family][i_form]+0]=Form("A_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+1]=Form("kx_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+2]=Form("x0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+3]=Form("y0_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
        par_names[n_pars[i_term][i_family][i_form]+4]=Form("phi_%d_%s_%s", i_term+1, name_family[i_family].c_str(), name_form[i_form].c_str());
      }

      arglist[0] = 1000000;
      arglist[1] = 0.0001;

      gMinuit_fit_pars->mnexcm("MIGRAD", arglist ,2,ierflg);



      clog<<itry<<"     chi2="<<chi2_fit<<endl;
      if (chi2_min_best>chi2_fit)
      {
        chi2_min_best = chi2_fit;
        clog<<"try:"<<itry<<" better fit parameters are found   with chi2="<<chi2_fit<<"    saved in fit_parameters.txt (or best_fit_parameters.txt)."<<endl;
        clog<<"\033[1;34m If you are not satisfied with the current results, let the code continue working (to avoid local minimums) \033[0m "<<endl;
        ofstream fout("best_fit_parameters.txt");
        fout<<"chi2="<<chi2_fit<<endl;

        for (int i=0; i<n_total; i++)
        {
          gMinuit_fit_pars->GetParameter(i, fit_par_res[i], fit_par_res_Err[i]);
        }
        for (int i=0; i<n_total; i++)
        {
          if (i%5==0) fout<<endl;
          fout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<fit_par_res[i]<<setw(20)<<"    error: "<<fit_par_res_Err[i]<<endl;
          fit_par_tmp[i]=fit_par_res[i];
        }
        fout.close();
        draw_control_plots(0, 0);
        int a=system("mv field_profile.gif best_field_profile.gif");
        cout<<endl;
      }
    }
    cout<<"final chi2="<<chi2_min_best<<endl;
    for (int i=0; i<n_total; i++)
    {
      cout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<fit_par_res[i]<<setw(20)<<"    error: "<<fit_par_res_Err[i]<<endl;
    }

    delete gMinuit_fit_pars;
    delete rnd_2;
}


void fcn_family_form(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag)
{
  //this function is needed by minuit
  //it will fit the data points using function func_new()
//calculate chisquare
  Double_t chisq = 0;
  Double_t chi2_0 = 0;
  Double_t delta2 = 0;

  for (int i_x=0; i_x<nx; i_x++)
  for (int i_y=0; i_y<ny; i_y++)
  for (int i_z=0; i_z<nz; i_z++)
  {
    TVector3 B_vec=func_family_form(x_bmad[i_x][i_y][i_z], y_bmad[i_x][i_y][i_z], z_bmad[i_x][i_y][i_z], par);
    double bx_func = B_vec[0];
    double by_func = B_vec[1];
    double bz_func = B_vec[2];
    delta2  = (bx_func-bx_bmad[i_x][i_y][i_z])*(bx_func-bx_bmad[i_x][i_y][i_z])/(field_error_x*field_error_x);
    delta2 += (by_func-by_bmad[i_x][i_y][i_z])*(by_func-by_bmad[i_x][i_y][i_z])/(field_error_y*field_error_y);
    delta2 += (bz_func-bz_bmad[i_x][i_y][i_z])*(bz_func-bz_bmad[i_x][i_y][i_z])/(field_error_z*field_error_z);
    chisq += delta2/double(nx*ny*nz);
  }
  f = chisq;
  chi2_fit=f;
  n_fit++;
  if(status_monitor)
  {
    if (n_fit%1000==0) 
    {
      cout<<"fit try:"<<itry<<";      function call number="<<n_fit<<"; \033[1;31m"<<"   current chi2="<<f<<"\033[0m  (this is just a status report, the fit is not finished)"<<endl;
      for (int i_par=0; i_par< n_max_pars; i_par++) fit_par_tmp[i_par]=par[i_par];
      draw_control_plots(0, 0);
      int a=system("date");
      ofstream fout("fit_parameters.txt");
      fout<<"fit try:"<<itry<<";      function call number="<<n_fit<<";    current chi2="<<f<<endl;
      for (int i=0; i<n_total; i++)
      {
        if (i%5==0) fout<<endl;
        fout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<par[i]<<endl;
      }
      cout<<endl;
      fout.close();
    }
  }
}



double fcn_family_form_minimizer(const double *par)
{
  //this function is needed by minuit
  //it will fit the data points using function func_new()
//calculate chisquare

  Double_t chisq = 0;
  Double_t chi2_0 = 0;
  Double_t delta2 = 0;

  for (int i_x=0; i_x<nx; i_x++)
  for (int i_y=0; i_y<ny; i_y++)
  for (int i_z=0; i_z<nz; i_z++)
  {
    TVector3 B_vec=func_family_form_minimizer(x_bmad[i_x][i_y][i_z], y_bmad[i_x][i_y][i_z], z_bmad[i_x][i_y][i_z], par);
    double bx_func = B_vec[0];
    double by_func = B_vec[1];
    double bz_func = B_vec[2];
    delta2  = (bx_func-bx_bmad[i_x][i_y][i_z])*(bx_func-bx_bmad[i_x][i_y][i_z])/(field_error_x*field_error_x);
    delta2 += (by_func-by_bmad[i_x][i_y][i_z])*(by_func-by_bmad[i_x][i_y][i_z])/(field_error_y*field_error_y);
    delta2 += (bz_func-bz_bmad[i_x][i_y][i_z])*(bz_func-bz_bmad[i_x][i_y][i_z])/(field_error_z*field_error_z);
    chisq += delta2/double(nx*ny*nz);
  }
  n_fit++;

  if(status_monitor)
  {
    if (n_fit%100==0) 
    {
      cout<<"fit try:"<<itry<<";      function call number="<<n_fit<<"; \033[1;31m"<<"   current chi2="<<chisq<<"\033[0m  (this is just a status report, the fit is not finished)"<<endl;
      for (int i_par=0; i_par< n_max_pars; i_par++) fit_par_tmp[i_par]=par[i_par];
      draw_control_plots(0, 0);
      int a=system("date");
      ofstream fout("fit_parameters.txt");
      fout<<"fit try:"<<itry<<";      function call number="<<n_fit<<";    current chi2="<<chisq<<endl;
      for (int i=0; i<n_total; i++)
      {
        if (i%5==0) fout<<endl;
        fout<<"par:"<<i<<setw(25)<<par_names[i]<<setw(20)<<par[i]<<endl;
      }
      cout<<endl;
      fout.close();
    }
  }
  return chisq;
}


TVector3 func_family_form(double x, double y, double z, Double_t *par)
{
  //Cartesian map functions
  double x_bx_fn=0;
  double x_by_fn=0;
  double x_bz_fn=0;
  double y_bx_fn=0;
  double y_by_fn=0;
  double y_bz_fn=0;
  double qu_bx_fn=0;
  double qu_by_fn=0;
  double qu_bz_fn=0;
  double sq_bx_fn=0;
  double sq_by_fn=0;
  double sq_bz_fn=0;

  double bx_fn=0;
  double by_fn=0;
  double bz_fn=0;

  double x_A1;
  double x_kx;
  double x_ky;
  double x_kz;
  double x_x0;
  double x_y0;
  double x_phi_z;

  double y_A1;
  double y_kx;
  double y_ky;
  double y_kz;
  double y_x0;
  double y_y0;
  double y_phi_z;

  double sq_A1;
  double sq_kx;
  double sq_ky;
  double sq_kz;
  double sq_x0;
  double sq_y0;
  double sq_phi_z;

  double qu_A1;
  double qu_kx;
  double qu_ky;
  double qu_kz;
  double qu_x0;
  double qu_y0;
  double qu_phi_z;

  for (int i_term=0; i_term<n_terms; i_term++)
  {
    //x-family functions
    {
      x_kz=kz_terms[i_term];

      if (use_family_form[i_term][0][0])
      {
        if(debug_mode) cout<<"x family, hyper y"<<endl;
        x_A1=par[n_pars[i_term][0][0]+0];
        x_kx=par[n_pars[i_term][0][0]+1];
        x_x0=par[n_pars[i_term][0][0]+2];
        x_y0=par[n_pars[i_term][0][0]+3];
        x_phi_z=par[n_pars[i_term][0][0]+4];
        x_ky=sqrt(x_kz*x_kz+x_kx*x_kx);
        x_bx_fn +=  x_A1 * x_kx/x_ky * cos(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn +=  x_A1 *             sin(x_kx*(x + x_x0)) * TMath::SinH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 * x_kz/x_ky * sin(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }

      if (use_family_form[i_term][0][1])
      if (x_kx<x_kz)
      {
        if(debug_mode) cout<<"x family, hyper xy"<<endl;
        x_A1=par[n_pars[i_term][0][1]+0];
        x_kx=par[n_pars[i_term][0][1]+1];
        x_x0=par[n_pars[i_term][0][1]+2];
        x_y0=par[n_pars[i_term][0][1]+3];
        x_phi_z=par[n_pars[i_term][0][1]+4];
        x_ky=sqrt(x_kz*x_kz-x_kx*x_kx);
        x_bx_fn +=  x_A1 * x_kx/x_kz * TMath::CosH(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn +=  x_A1 * x_ky/x_kz * TMath::SinH(x_kx*(x + x_x0)) * TMath::SinH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 *             TMath::SinH(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }

      if (use_family_form[i_term][0][2])
      {
        if(debug_mode) cout<<"x family, hyper x"<<endl;
        x_A1=par[n_pars[i_term][0][2]+0];
        x_kx=par[n_pars[i_term][0][2]+1];
        x_x0=par[n_pars[i_term][0][2]+2];
        x_y0=par[n_pars[i_term][0][2]+3];
        x_phi_z=par[n_pars[i_term][0][2]+4];
        x_ky=sqrt(-x_kz*x_kz+x_kx*x_kx);
        x_bx_fn +=  x_A1 *            TMath::CosH(x_kx*(x + x_x0)) * cos(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn += -x_A1 * x_ky/x_kx* TMath::SinH(x_kx*(x + x_x0)) * sin(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 * x_kz/x_kx* TMath::SinH(x_kx*(x + x_x0)) * cos(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }
    }


    //y-family functions
    {
      y_kz=kz_terms[i_term];

      if (use_family_form[i_term][1][0])
      {
        if(debug_mode) cout<<"y family, hyper y"<<endl;
        y_A1=par[n_pars[i_term][1][0]+0];
        y_kx=par[n_pars[i_term][1][0]+1];
        y_x0=par[n_pars[i_term][1][0]+2];
        y_y0=par[n_pars[i_term][1][0]+3];
        y_phi_z=par[n_pars[i_term][1][0]+4];
        y_ky=sqrt(y_kz*y_kz+y_kx*y_kx);
        y_bx_fn += -y_A1 * y_kx/y_ky * sin(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn +=  y_A1 *             cos(y_kx*(x + y_x0)) * TMath::CosH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 * y_kz/y_ky * cos(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }

      if (use_family_form[i_term][1][1])
      if (y_kx<y_kz)
      {
        if(debug_mode) cout<<"y family, hyper xy"<<endl;
        y_A1=par[n_pars[i_term][1][1]+0];
        y_kx=par[n_pars[i_term][1][1]+1];
        y_x0=par[n_pars[i_term][1][1]+2];
        y_y0=par[n_pars[i_term][1][1]+3];
        y_phi_z=par[n_pars[i_term][1][1]+4];
        y_ky=sqrt(y_kz*y_kz-y_kx*y_kx);
        y_bx_fn += y_A1 * y_kx/y_kz * TMath::SinH(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn += y_A1 * y_ky/y_kz * TMath::CosH(y_kx*(x + y_x0)) * TMath::CosH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 *            TMath::CosH(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }

      if (use_family_form[i_term][1][2])
      {
        if(debug_mode) cout<<"y family, hyper x"<<endl;
        y_A1=par[n_pars[i_term][1][2]+0];
        y_kx=par[n_pars[i_term][1][2]+1];
        y_x0=par[n_pars[i_term][1][2]+2];
        y_y0=par[n_pars[i_term][1][2]+3];
        y_phi_z=par[n_pars[i_term][1][2]+4];
        y_ky=sqrt(-y_kz*y_kz+y_kx*y_kx);
        y_bx_fn +=  y_A1 *            TMath::SinH(y_kx*(x + y_x0)) * sin(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn +=  y_A1 * y_ky/y_kx* TMath::CosH(y_kx*(x + y_x0)) * cos(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 * y_kz/y_kx* TMath::CosH(y_kx*(x + y_x0)) * sin(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }
    }

    //qu-family functions
    {
      qu_kz=kz_terms[i_term];

      if (use_family_form[i_term][2][0])
      {
        if(debug_mode) cout<<"qu family, hyper y"<<endl;
        qu_A1=par[n_pars[i_term][2][0]+0];
        qu_kx=par[n_pars[i_term][2][0]+1];
        qu_x0=par[n_pars[i_term][2][0]+2];
        qu_y0=par[n_pars[i_term][2][0]+3];
        qu_phi_z=par[n_pars[i_term][2][0]+4];
        qu_ky=sqrt(qu_kz*qu_kz+qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 * qu_kx/qu_ky * cos(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 *               sin(qu_kx*(x + qu_x0)) * TMath::CosH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 * qu_kz/qu_ky * sin(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }

      if (use_family_form[i_term][2][1])
      {
        if(debug_mode) cout<<"qu family, hyper xy"<<endl;
        qu_A1=par[n_pars[i_term][2][1]+0];
        qu_kx=par[n_pars[i_term][2][1]+1];
        qu_x0=par[n_pars[i_term][2][1]+2];
        qu_y0=par[n_pars[i_term][2][1]+3];
        qu_phi_z=par[n_pars[i_term][2][1]+4];
        qu_ky=sqrt(qu_kz*qu_kz-qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 * qu_kx/qu_kz * TMath::CosH(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 * qu_ky/qu_kz * TMath::SinH(qu_kx*(x + qu_x0)) * TMath::CosH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 *               TMath::SinH(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }

      if (use_family_form[i_term][2][2])
      {
        if(debug_mode) cout<<"qu family, hyper x"<<endl;
        qu_A1=par[n_pars[i_term][2][2]+0];
        qu_kx=par[n_pars[i_term][2][2]+1];
        qu_x0=par[n_pars[i_term][2][2]+2];
        qu_y0=par[n_pars[i_term][2][2]+3];
        qu_phi_z=par[n_pars[i_term][2][2]+4];
        qu_ky=sqrt(-qu_kz*qu_kz+qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 *              TMath::CosH(qu_kx*(x + qu_x0)) * sin(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 * qu_ky/qu_kx* TMath::SinH(qu_kx*(x + qu_x0)) * cos(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 * qu_kz/qu_kx* TMath::SinH(qu_kx*(x + qu_x0)) * sin(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }
    }

    //sq-family functions
    {
      sq_kz=kz_terms[i_term];

      if (use_family_form[i_term][3][0])
      {
        if(debug_mode) cout<<"sq family, hyper y"<<endl;
        sq_A1=par[n_pars[i_term][3][0]+0];
        sq_kx=par[n_pars[i_term][3][0]+1];
        sq_x0=par[n_pars[i_term][3][0]+2];
        sq_y0=par[n_pars[i_term][3][0]+3];
        sq_phi_z=par[n_pars[i_term][3][0]+4];
        sq_ky=sqrt(sq_kz*sq_kz+sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 * sq_kx/sq_ky * sin(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 *               cos(sq_kx*(x + sq_x0)) * TMath::SinH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 * sq_kz/sq_ky * cos(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }

      if (use_family_form[i_term][3][1])
      {
        if(debug_mode) cout<<"sq family, hyper xy"<<endl;
        sq_A1=par[n_pars[i_term][3][1]+0];
        sq_kx=par[n_pars[i_term][3][1]+1];
        sq_x0=par[n_pars[i_term][3][1]+2];
        sq_y0=par[n_pars[i_term][3][1]+3];
        sq_phi_z=par[n_pars[i_term][3][1]+4];
        sq_ky=sqrt(sq_kz*sq_kz-sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 * sq_kx/sq_kz * TMath::SinH(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 * sq_ky/sq_kz * TMath::CosH(sq_kx*(x + sq_x0)) * TMath::SinH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 *               TMath::CosH(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }

      if (use_family_form[i_term][3][2])
      {
        if(debug_mode) cout<<"sq family, hyper x"<<endl;
        sq_A1=par[n_pars[i_term][3][2]+0];
        sq_kx=par[n_pars[i_term][3][2]+1];
        sq_x0=par[n_pars[i_term][3][2]+2];
        sq_y0=par[n_pars[i_term][3][2]+3];
        sq_phi_z=par[n_pars[i_term][3][2]+4];
        sq_ky=sqrt(-sq_kz*sq_kz+sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 *              TMath::SinH(sq_kx*(x + sq_x0)) * cos(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 * sq_ky/sq_kx* TMath::CosH(sq_kx*(x + sq_x0)) * sin(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 * sq_kz/sq_kx* TMath::CosH(sq_kx*(x + sq_x0)) * cos(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }
    }
  }
  bx_fn=x_bx_fn+y_bx_fn+qu_bx_fn+sq_bx_fn;
  by_fn=x_by_fn+y_by_fn+qu_by_fn+sq_by_fn;
  bz_fn=x_bz_fn+y_bz_fn+qu_bz_fn+sq_bz_fn;
  if (debug_mode)
  {
    cout<<setw(20)<<x_bx_fn<<setw(20)<<x_by_fn<<setw(20)<<x_bz_fn<<endl;
    cout<<setw(20)<<y_bx_fn<<setw(20)<<y_by_fn<<setw(20)<<y_bz_fn<<endl;
    cout<<setw(20)<<qu_bx_fn<<setw(20)<<qu_by_fn<<setw(20)<<qu_bz_fn<<endl;
    cout<<setw(20)<<sq_bx_fn<<setw(20)<<sq_by_fn<<setw(20)<<sq_bz_fn<<endl<<endl<<endl<<endl;
  }
  TVector3 B_fam(bx_fn, by_fn, bz_fn);
  return B_fam;
}



TVector3 func_family_form_minimizer(double x, double y, double z, const double *par)
{
  //Cartesian map functions
  double x_bx_fn=0;
  double x_by_fn=0;
  double x_bz_fn=0;
  double y_bx_fn=0;
  double y_by_fn=0;
  double y_bz_fn=0;
  double qu_bx_fn=0;
  double qu_by_fn=0;
  double qu_bz_fn=0;
  double sq_bx_fn=0;
  double sq_by_fn=0;
  double sq_bz_fn=0;

  double bx_fn=0;
  double by_fn=0;
  double bz_fn=0;

  double x_A1;
  double x_kx;
  double x_ky;
  double x_kz;
  double x_x0;
  double x_y0;
  double x_phi_z;

  double y_A1;
  double y_kx;
  double y_ky;
  double y_kz;
  double y_x0;
  double y_y0;
  double y_phi_z;

  double sq_A1;
  double sq_kx;
  double sq_ky;
  double sq_kz;
  double sq_x0;
  double sq_y0;
  double sq_phi_z;

  double qu_A1;
  double qu_kx;
  double qu_ky;
  double qu_kz;
  double qu_x0;
  double qu_y0;
  double qu_phi_z;

  for (int i_term=0; i_term<n_terms; i_term++)
  {
    //x-family functions
    {
      x_kz=kz_terms[i_term];

      if (use_family_form[i_term][0][0])
      {
        if(debug_mode) cout<<"x family, hyper y"<<endl;
        x_A1=par[n_pars[i_term][0][0]+0];
        x_kx=par[n_pars[i_term][0][0]+1];
        x_x0=par[n_pars[i_term][0][0]+2];
        x_y0=par[n_pars[i_term][0][0]+3];
        x_phi_z=par[n_pars[i_term][0][0]+4];
        x_ky=sqrt(x_kz*x_kz+x_kx*x_kx);
        x_bx_fn +=  x_A1 * x_kx/x_ky * cos(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn +=  x_A1 *             sin(x_kx*(x + x_x0)) * TMath::SinH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 * x_kz/x_ky * sin(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }

      if (use_family_form[i_term][0][1])
      if (x_kx<x_kz)
      {
        if(debug_mode) cout<<"x family, hyper xy"<<endl;
        x_A1=par[n_pars[i_term][0][1]+0];
        x_kx=par[n_pars[i_term][0][1]+1];
        x_x0=par[n_pars[i_term][0][1]+2];
        x_y0=par[n_pars[i_term][0][1]+3];
        x_phi_z=par[n_pars[i_term][0][1]+4];
        x_ky=sqrt(x_kz*x_kz-x_kx*x_kx);
        x_bx_fn +=  x_A1 * x_kx/x_kz * TMath::CosH(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn +=  x_A1 * x_ky/x_kz * TMath::SinH(x_kx*(x + x_x0)) * TMath::SinH(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 *             TMath::SinH(x_kx*(x + x_x0)) * TMath::CosH(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }

      if (use_family_form[i_term][0][2])
      {
        if(debug_mode) cout<<"x family, hyper x"<<endl;
        x_A1=par[n_pars[i_term][0][2]+0];
        x_kx=par[n_pars[i_term][0][2]+1];
        x_x0=par[n_pars[i_term][0][2]+2];
        x_y0=par[n_pars[i_term][0][2]+3];
        x_phi_z=par[n_pars[i_term][0][2]+4];
        x_ky=sqrt(-x_kz*x_kz+x_kx*x_kx);
        x_bx_fn +=  x_A1 *            TMath::CosH(x_kx*(x + x_x0)) * cos(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_by_fn += -x_A1 * x_ky/x_kx* TMath::SinH(x_kx*(x + x_x0)) * sin(x_ky*(y + x_y0)) * cos(x_kz*z + x_phi_z);
        x_bz_fn += -x_A1 * x_kz/x_kx* TMath::SinH(x_kx*(x + x_x0)) * cos(x_ky*(y + x_y0)) * sin(x_kz*z + x_phi_z);
      }
    }


    //y-family functions
    {
      y_kz=kz_terms[i_term];

      if (use_family_form[i_term][1][0])
      {
        if(debug_mode) cout<<"y family, hyper y"<<endl;
        y_A1=par[n_pars[i_term][1][0]+0];
        y_kx=par[n_pars[i_term][1][0]+1];
        y_x0=par[n_pars[i_term][1][0]+2];
        y_y0=par[n_pars[i_term][1][0]+3];
        y_phi_z=par[n_pars[i_term][1][0]+4];
        y_ky=sqrt(y_kz*y_kz+y_kx*y_kx);
        y_bx_fn += -y_A1 * y_kx/y_ky * sin(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn +=  y_A1 *             cos(y_kx*(x + y_x0)) * TMath::CosH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 * y_kz/y_ky * cos(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }

      if (use_family_form[i_term][1][1])
      if (y_kx<y_kz)
      {
        if(debug_mode) cout<<"y family, hyper xy"<<endl;
        y_A1=par[n_pars[i_term][1][1]+0];
        y_kx=par[n_pars[i_term][1][1]+1];
        y_x0=par[n_pars[i_term][1][1]+2];
        y_y0=par[n_pars[i_term][1][1]+3];
        y_phi_z=par[n_pars[i_term][1][1]+4];
        y_ky=sqrt(y_kz*y_kz-y_kx*y_kx);
        y_bx_fn += y_A1 * y_kx/y_kz * TMath::SinH(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn += y_A1 * y_ky/y_kz * TMath::CosH(y_kx*(x + y_x0)) * TMath::CosH(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 *            TMath::CosH(y_kx*(x + y_x0)) * TMath::SinH(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }

      if (use_family_form[i_term][1][2])
      {
        if(debug_mode) cout<<"y family, hyper x"<<endl;
        y_A1=par[n_pars[i_term][1][2]+0];
        y_kx=par[n_pars[i_term][1][2]+1];
        y_x0=par[n_pars[i_term][1][2]+2];
        y_y0=par[n_pars[i_term][1][2]+3];
        y_phi_z=par[n_pars[i_term][1][2]+4];
        y_ky=sqrt(-y_kz*y_kz+y_kx*y_kx);
        y_bx_fn +=  y_A1 *            TMath::SinH(y_kx*(x + y_x0)) * sin(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_by_fn +=  y_A1 * y_ky/y_kx* TMath::CosH(y_kx*(x + y_x0)) * cos(y_ky*(y + y_y0)) * cos(y_kz*z + y_phi_z);
        y_bz_fn += -y_A1 * y_kz/y_kx* TMath::CosH(y_kx*(x + y_x0)) * sin(y_ky*(y + y_y0)) * sin(y_kz*z + y_phi_z);
      }
    }

    //qu-family functions
    {
      qu_kz=kz_terms[i_term];

      if (use_family_form[i_term][2][0])
      {
        if(debug_mode) cout<<"qu family, hyper y"<<endl;
        qu_A1=par[n_pars[i_term][2][0]+0];
        qu_kx=par[n_pars[i_term][2][0]+1];
        qu_x0=par[n_pars[i_term][2][0]+2];
        qu_y0=par[n_pars[i_term][2][0]+3];
        qu_phi_z=par[n_pars[i_term][2][0]+4];
        qu_ky=sqrt(qu_kz*qu_kz+qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 * qu_kx/qu_ky * cos(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 *               sin(qu_kx*(x + qu_x0)) * TMath::CosH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 * qu_kz/qu_ky * sin(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }

      if (use_family_form[i_term][2][1])
      {
        if(debug_mode) cout<<"qu family, hyper xy"<<endl;
        qu_A1=par[n_pars[i_term][2][1]+0];
        qu_kx=par[n_pars[i_term][2][1]+1];
        qu_x0=par[n_pars[i_term][2][1]+2];
        qu_y0=par[n_pars[i_term][2][1]+3];
        qu_phi_z=par[n_pars[i_term][2][1]+4];
        qu_ky=sqrt(qu_kz*qu_kz-qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 * qu_kx/qu_kz * TMath::CosH(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 * qu_ky/qu_kz * TMath::SinH(qu_kx*(x + qu_x0)) * TMath::CosH(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 *               TMath::SinH(qu_kx*(x + qu_x0)) * TMath::SinH(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }

      if (use_family_form[i_term][2][2])
      {
        if(debug_mode) cout<<"qu family, hyper x"<<endl;
        qu_A1=par[n_pars[i_term][2][2]+0];
        qu_kx=par[n_pars[i_term][2][2]+1];
        qu_x0=par[n_pars[i_term][2][2]+2];
        qu_y0=par[n_pars[i_term][2][2]+3];
        qu_phi_z=par[n_pars[i_term][2][2]+4];
        qu_ky=sqrt(-qu_kz*qu_kz+qu_kx*qu_kx);
        qu_bx_fn +=  qu_A1 *              TMath::CosH(qu_kx*(x + qu_x0)) * sin(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_by_fn +=  qu_A1 * qu_ky/qu_kx* TMath::SinH(qu_kx*(x + qu_x0)) * cos(qu_ky*(y + qu_y0)) * cos(qu_kz*z + qu_phi_z);
        qu_bz_fn += -qu_A1 * qu_kz/qu_kx* TMath::SinH(qu_kx*(x + qu_x0)) * sin(qu_ky*(y + qu_y0)) * sin(qu_kz*z + qu_phi_z);
      }
    }

    //sq-family functions
    {
      sq_kz=kz_terms[i_term];

      if (use_family_form[i_term][3][0])
      {
        if(debug_mode) cout<<"sq family, hyper y"<<endl;
        sq_A1=par[n_pars[i_term][3][0]+0];
        sq_kx=par[n_pars[i_term][3][0]+1];
        sq_x0=par[n_pars[i_term][3][0]+2];
        sq_y0=par[n_pars[i_term][3][0]+3];
        sq_phi_z=par[n_pars[i_term][3][0]+4];
        sq_ky=sqrt(sq_kz*sq_kz+sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 * sq_kx/sq_ky * sin(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 *               cos(sq_kx*(x + sq_x0)) * TMath::SinH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 * sq_kz/sq_ky * cos(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }

      if (use_family_form[i_term][3][1])
      {
        if(debug_mode) cout<<"sq family, hyper xy"<<endl;
        sq_A1=par[n_pars[i_term][3][1]+0];
        sq_kx=par[n_pars[i_term][3][1]+1];
        sq_x0=par[n_pars[i_term][3][1]+2];
        sq_y0=par[n_pars[i_term][3][1]+3];
        sq_phi_z=par[n_pars[i_term][3][1]+4];
        sq_ky=sqrt(sq_kz*sq_kz-sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 * sq_kx/sq_kz * TMath::SinH(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 * sq_ky/sq_kz * TMath::CosH(sq_kx*(x + sq_x0)) * TMath::SinH(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 *               TMath::CosH(sq_kx*(x + sq_x0)) * TMath::CosH(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }

      if (use_family_form[i_term][3][2])
      {
        if(debug_mode) cout<<"sq family, hyper x"<<endl;
        sq_A1=par[n_pars[i_term][3][2]+0];
        sq_kx=par[n_pars[i_term][3][2]+1];
        sq_x0=par[n_pars[i_term][3][2]+2];
        sq_y0=par[n_pars[i_term][3][2]+3];
        sq_phi_z=par[n_pars[i_term][3][2]+4];
        sq_ky=sqrt(-sq_kz*sq_kz+sq_kx*sq_kx);
        sq_bx_fn +=  sq_A1 *              TMath::SinH(sq_kx*(x + sq_x0)) * cos(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_by_fn +=  sq_A1 * sq_ky/sq_kx* TMath::CosH(sq_kx*(x + sq_x0)) * sin(sq_ky*(y + sq_y0)) * cos(sq_kz*z + sq_phi_z);
        sq_bz_fn += -sq_A1 * sq_kz/sq_kx* TMath::CosH(sq_kx*(x + sq_x0)) * cos(sq_ky*(y + sq_y0)) * sin(sq_kz*z + sq_phi_z);
      }
    }
  }
  bx_fn=x_bx_fn+y_bx_fn+qu_bx_fn+sq_bx_fn;
  by_fn=x_by_fn+y_by_fn+qu_by_fn+sq_by_fn;
  bz_fn=x_bz_fn+y_bz_fn+qu_bz_fn+sq_bz_fn;
  if (debug_mode)
  {
    cout<<setw(20)<<x_bx_fn<<setw(20)<<x_by_fn<<setw(20)<<x_bz_fn<<endl;
    cout<<setw(20)<<y_bx_fn<<setw(20)<<y_by_fn<<setw(20)<<y_bz_fn<<endl;
    cout<<setw(20)<<qu_bx_fn<<setw(20)<<qu_by_fn<<setw(20)<<qu_bz_fn<<endl;
    cout<<setw(20)<<sq_bx_fn<<setw(20)<<sq_by_fn<<setw(20)<<sq_bz_fn<<endl<<endl<<endl<<endl;
  }
  TVector3 B_fam(bx_fn, by_fn, bz_fn);
  return B_fam;
}



void draw_control_plots(int i_x, int i_y)
{
  double x_gr[nz];
  double y_gr[nz];
  double z_gr[nz];

  double bx_gr[nz];
  double by_gr[nz];
  double bz_gr[nz];

  double bx_fit_gr[nz];
  double by_fit_gr[nz];
  double bz_fit_gr[nz];

  for (int i=0; i<nz; i++)
  {
    TVector3 B_vec=func_family_form(x_bmad[i_x][i_y][i], y_bmad[i_x][i_y][i], z_bmad[i_x][i_y][i], fit_par_tmp);
    bx_fit_gr[i] = B_vec[0];
    by_fit_gr[i] = B_vec[1];
    bz_fit_gr[i] = B_vec[2];
    x_gr[i]=x_bmad[i_x][i_y][i];
    y_gr[i]=y_bmad[i_x][i_y][i];
    z_gr[i]=z_bmad[i_x][i_y][i];
    bx_gr[i]=bx_bmad[i_x][i_y][i];
    by_gr[i]=by_bmad[i_x][i_y][i];
    bz_gr[i]=bz_bmad[i_x][i_y][i];
  }
  TGraph *gr_bx=new TGraph(nz, z_gr, bx_gr);
  TGraph *gr_by=new TGraph(nz, z_gr, by_gr);
  TGraph *gr_bz=new TGraph(nz, z_gr, bz_gr);

  TGraph *gr_bx_fit=new TGraph(nz, z_gr, bx_fit_gr);
  TGraph *gr_by_fit=new TGraph(nz, z_gr, by_fit_gr);
  TGraph *gr_bz_fit=new TGraph(nz, z_gr, bz_fit_gr);

  gr_bx->SetMarkerStyle(7);
  gr_by->SetMarkerStyle(7);
  gr_bz->SetMarkerStyle(7);
  gr_bx_fit->SetMarkerStyle(7);
  gr_by_fit->SetMarkerStyle(7);
  gr_bz_fit->SetMarkerStyle(7);
  gr_bx_fit->SetMarkerColor(2);
  gr_by_fit->SetMarkerColor(2);
  gr_bz_fit->SetMarkerColor(2);

  gr_bx->SetTitle("Bx vs z");
  gr_by->SetTitle("By vs z");
  gr_bz->SetTitle("Bz vs z");

  gr_bx->GetXaxis()->SetTitle("z");
  gr_bx->GetYaxis()->SetTitle("Bx");
  gr_by->GetXaxis()->SetTitle("z");
  gr_by->GetYaxis()->SetTitle("By");
  gr_bz->GetXaxis()->SetTitle("z");
  gr_bz->GetYaxis()->SetTitle("Bz");

  TLegend *leg = new TLegend(0.55, 0.85, 0.99, 0.99);
  leg->AddEntry(gr_bx, "Field input data", "p");
  leg->AddEntry(gr_bx_fit, "Field fit", "p");
  cc->cd(1);
  gr_bx->Draw("AP");
  gr_bx_fit->Draw("PSame");
  leg->Draw();
  cc->cd(2);
  gr_by->Draw("AP");
  gr_by_fit->Draw("PSame");
  cc->cd(3);
  gr_bz->Draw("AP");
  gr_bz_fit->Draw("PSame");
  cc->SaveAs("field_profile.gif");
  cc->Update();
  cc->Modified();
}
